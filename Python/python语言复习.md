####学习记录：

###一节

1、Python允许用`r''`表示`''`内部的字符串默认不转义。

2、对于单个字符的编码，Python提供了`ord()`函数获取字符的整数表示，`chr()`函数把编码转换为对应的字符。

###list

```
 classmates = ['Michael', 'Bob', 'Tracy']
```

Python内置的一种数据类型是列表

list是一种有序的集合，可以随时添加和删除其中的元素。

用索引来访问list中每一个位置的元素，记得索引是从`0`开始的。

append()可以往list中追加元素到末尾。

list里面的元素的数据类型也可以不同

list元素也可以是另一个list

### tuple

```
classmates = ('Michael', 'Bob', 'Tracy')
```

另一种有序列表叫元组：tuple。tuple和list非常类似，但是

#####tuple一旦初始化就不能修改。

因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

只有1个元素的tuple定义时必须加一个逗号`,`。



### 总结

list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。



### 二节

基本语法：

Python的缩进规则

```
age = 3
if age >= 18:
    print('your age is', age)
    print('adult')
else:
    print('your age is', age)
    print('teenager')
```

如果`if`语句判断是`True`，就把缩进的两行print语句执行了。

```
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```

`input()`返回的数据类型是`str`

`for x in ...`循环就是把每个元素代入变量`x`，然后执行

`range()`函数，可以生成一个整数序列，再通过`list()`函数可以转换为list。

### 三节

#### dict

Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。

把数据放入dict的方法，除了初始化时指定外，还可以通过key放入。

要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在。二是通过dict提供的`get()`方法，如果key不存在，可以返回`None`。

要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除。

dict的key必须是**不可变对象**。



#####小结

和list比较，dict有以下几个特点：

1. 查找和插入的速度极快，不会随着key的增加而变慢；
2. 需要占用大量的内存，内存浪费多。

而list相反：

1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

所以，dict是用空间来换取时间的一种方法。

#### set

set和dict类似，也是一组key的集合，但不存储value，在set中，没有重复的key。

要创建一个set，需要提供一个list作为输入集合。

重复元素在set中自动被过滤。

通过`add(key)`方法可以添加元素到set中。

通过`remove(key)`方法可以删除元素。

set可以看成数学意义上的无序和无重复元素的集合。



### 四节

在Python中，定义一个函数要使用`def`语句，依次写出函数名、括号、括号中的参数和冒号`:`，然后，在缩进块中编写函数体，函数的返回值用`return`语句返回。

    def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
`return None`可以简写为`return`。

### 空函数

如果想定义一个什么事也不做的空函数，可以用`pass`语句：

```
def nop():
    pass
```

`pass`语句什么都不做，那有什么用？实际上`pass`可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个`pass`，让代码能运行起来。

错误和异常处理。

### 返回多个值

返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple。

### 小结

定义函数时，需要确定函数名和参数个数；

如果有必要，可以先对参数的数据类型做检查；

函数体内部可以用`return`随时返回函数结果；

函数执行完毕也没有`return`语句时，自动`return None`。

函数可以同时返回多个值，但其实就是一个tuple。



#### 函数参数

####默认参数

默认参数降低了函数调用的难度。

```
def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
```

##### 可变参数

定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple。

```
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```

`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。

##### 关键字参数

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

```
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
```

函数`person`除了必选参数`name`和`age`外，还接受关键字参数`kw`。在调用该函数时，可以只传入必选参数。

##### 关键字参数有什么用？它可以扩展函数的功能。

组装出一个dict，然后，把该dict转换为关键字参数传给函数。

`**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`。

######命名关键字参数：如果要限制关键字参数的名字，就可以用命名关键字参数。

```
def person(name, age, *, city, job):
    print(name, age, city, job)
```

和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。

使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个`*`作为特殊分隔符。如果缺少`*`，Python解释器将无法识别位置参数和命名关键字参数。

##### 位置参数 关键字参数 命名关键字参数

#### 参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的。



####另一个主题

外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。



#### 模块搜索路径

当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件。

默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在`sys`模块的`path`变量中。

如果我们要添加自己的搜索目录，有两种方法：

一是直接修改`sys.path`，添加要搜索的目录：这种方法是在运行时修改，运行结束后失效。

```
import sys
sys.path.append('/Users/youpath/my_py_scripts')
```

第二种方法是设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。



##### 错误处理

当我们认为某些代码可能会出错时，就可以用`try`来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即`except`语句块，执行完`except`后，如果有`finally`语句块，则执行`finally`语句块，至此，执行完毕。



### 解读错误信息是定位错误的关键。

出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。

### 记录错误

如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。

Python内置的`logging`模块可以非常容易地记录错误信息。



只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如`ValueError`，`TypeError`），尽量使用Python内置的错误类型。



##### Python内置的`try...except...finally`用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。

